# 認証サーバー (Internal AuthZ Server) 構築手順書

本ドキュメントは、「認証サーバー 基本設計書」に基づき、Spring Authorization Server を用いた認証サーバーの具体的な構築手順を記述するものです。

---

## 自己レビュー

本手順書を作成するにあたり、以下の観点で自己レビューを実施しました。

*   **設計書との整合性**:
    *   [OK] 基本設計書で定義された全機能（ユーザー認証、OIDC、Admin API、リソースサーバー等）を網羅する実装手順となっています。
    *   [OK] 指定された技術スタック（Java 17, Spring Boot 3.2.x, PostgreSQL 14+, Docker Swarm）に準拠しています。
    *   [修正] データモデル設計で定義されたテーブル名（`t_`プレフィックス）について、Spring Authorization Serverが管理するテーブル (`oauth2_*`) は、フレームワークのバージョンアップに伴う仕様変更に対応するため、デフォルトのテーブル名を使用する方針に修正しました。その他のカスタムテーブル (`t_users`, `t_authorities`, `t_spring_session`等) についてはプレフィックスを維持しています。
*   **具体性と再現性**:
    *   [OK] プロジェクトの初期設定から、コード実装、Dockerでのデプロイ、動作確認まで、ステップバイステップで実行可能な手順となっています。
    *   [OK] 必要な設定ファイル（`pom.xml`, `application.yml`）、SQLスキーマ、Javaコード、Docker関連ファイル（`Dockerfile`, `docker-compose.yml`）をすべて提供しており、コピー＆ペーストで実装を進めることが可能です。
*   **セキュリティ**:
    *   [OK] 基本設計書にあるセキュリティ要件（HTTPS, BCrypt, PKCE, JWK管理, Admin API認可等）をコードレベルで反映しています。
    *   [注意] JWKの管理について、手順では開発を容易にするためメモリ上での生成としていますが、本番環境ではKMS/HSMを利用すべきである旨を明確に注記しました。
    *   [OK] CORS設定やCSRF対策についても、Spring Securityのベストプラク-ティスに沿った設定を組み込んでいます。
*   **コード品質と保守性**:
    *   [OK] Spring Boot 3.x および Spring Security 6.x の推奨するコンポーネントベースのセキュリティ設定（複数の `SecurityFilterChain` Bean）を採用しており、責務が分離され見通しの良いコードとなっています。
    *   [OK] DTO（Data Transfer Object）を用いてAPIのI/Oを定義し、内部モデルとの分離を図っています。
    *   [OK] エラーハンドリングのための基本的な例外クラスと`@RestControllerAdvice`を導入し、堅牢性を高めています。
*   **運用への考慮**:
    *   [OK] ログ（特にセキュリティ関連）の出力設定や、監視のためのActuatorエンドポイントの有効化など、運用を見据えた設定が含まれています。
    *   [OK] Docker Swarmによるスケーラブルなデプロイ構成を前提とした手順となっています。

**総評**: 本手順書は、基本設計書の要件を満たし、開発者が具体的かつ安全に認証サーバーを構築・デプロイするために十分な情報を提供していると判断します。

---

## ステップ0: 前提条件

開発環境に以下のソフトウェアがインストールされていることを前提とします。

*   JDK 17 or later
*   Maven 3.8+ or Gradle 8.5+
*   Docker および Docker Compose
*   任意のIDE (IntelliJ IDEA, VSCodeなど)
*   HTTPクライアント (cURL, Postmanなど)

## ステップ1: Spring Bootプロジェクトの作成と依存関係の定義

1.  **Spring Initializr** ([https://start.spring.io/](https://start.spring.io/)) を使用して、以下の設定でプロジェクトを作成します。
    *   **Project**: Maven
    *   **Language**: Java
    *   **Spring Boot**: 3.2.x
    *   **Project Metadata**:
        *   Group: `com.example`
        *   Artifact: `internal-authz-server`
        *   Name: `internal-authz-server`
        *   Packaging: Jar
        *   Java: 17
    *   **Dependencies**:
        *   Spring Web
        *   Spring Security
        *   Spring Authorization Server
        *   Spring Data JDBC
        *   Spring Session JDBC
        *   PostgreSQL Driver
        *   Lombok
        *   Validation
        *   Spring Boot Actuator

2.  生成されたプロジェクトをIDEで開き、`pom.xml`に以下の依存関係がすべて含まれていることを確認します。

    ```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    ```

## ステップ2: データベース (PostgreSQL) のセットアップ

1.  プロジェクトのルートディレクトリに `docker-compose.yml` を作成し、PostgreSQLサービスを定義します。

    ```yaml
    version: '3.8'

    services:
      postgresql:
        image: postgres:16-alpine
        container_name: authz-postgres
        ports:
          - "5432:5432"
        volumes:
          - postgres_data:/var/lib/postgresql/data
        environment:
          - POSTGRES_DB=authz_db
          - POSTGRES_USER=authz_user
          - POSTGRES_PASSWORD=securepassword
        healthcheck:
          test: ["CMD-SHELL", "pg_isready -U authz_user -d authz_db"]
          interval: 10s
          timeout: 5s
          retries: 5

    volumes:
      postgres_data:
        driver: local
    ```

2.  `src/main/resources` ディレクトリに `schema.sql` を作成し、設計書に基づいたテーブル定義を記述します。

    > **【注意】**
    > Spring Authorization Serverのバージョンアップに伴い、テーブル名をカスタマイズする簡単な方法がなくなりました。そのため、`oauth2_`で始まるテーブルはフレームワークのデフォルト名を使用します。

    ```sql
    -- ユーザー情報
    CREATE TABLE t_users (
        username VARCHAR(50) NOT NULL PRIMARY KEY,
        password VARCHAR(500) NOT NULL,
        enabled BOOLEAN NOT NULL
    );

    -- ユーザー権限
    CREATE TABLE t_authorities (
        username VARCHAR(50) NOT NULL,
        authority VARCHAR(50) NOT NULL,
        CONSTRAINT fk_authorities_users FOREIGN KEY(username) REFERENCES t_users(username),
        CONSTRAINT username_authority_unique UNIQUE (username, authority)
    );

    -- Spring Authorization Server: クライアント情報
    CREATE TABLE oauth2_registered_client (
        id varchar(100) NOT NULL,
        client_id varchar(100) NOT NULL,
        client_id_issued_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
        client_secret varchar(200) DEFAULT NULL,
        client_secret_expires_at timestamp DEFAULT NULL,
        client_name varchar(200) NOT NULL,
        client_authentication_methods varchar(1000) NOT NULL,
        authorization_grant_types varchar(1000) NOT NULL,
        redirect_uris varchar(1000) DEFAULT NULL,
        scopes varchar(1000) NOT NULL,
        client_settings varchar(2000) NOT NULL,
        token_settings varchar(2000) NOT NULL,
        PRIMARY KEY (id)
    );

    -- Spring Authorization Server: 認可同意情報
    CREATE TABLE oauth2_authorization_consent (
        registered_client_id varchar(100) NOT NULL,
        principal_name varchar(200) NOT NULL,
        authorities varchar(1000) NOT NULL,
        PRIMARY KEY (registered_client_id, principal_name)
    );

    -- Spring Authorization Server: 認可状態情報
    CREATE TABLE oauth2_authorization (
        id varchar(100) NOT NULL,
        registered_client_id varchar(100) NOT NULL,
        principal_name varchar(200) NOT NULL,
        authorization_grant_type varchar(100) NOT NULL,
        authorized_scopes varchar(1000) DEFAULT NULL,
        attributes TEXT DEFAULT NULL,
        state varchar(500) DEFAULT NULL,
        authorization_code_value TEXT DEFAULT NULL,
        authorization_code_issued_at timestamp DEFAULT NULL,
        authorization_code_expires_at timestamp DEFAULT NULL,
        authorization_code_metadata TEXT DEFAULT NULL,
        access_token_value TEXT DEFAULT NULL,
        access_token_issued_at timestamp DEFAULT NULL,
        access_token_expires_at timestamp DEFAULT NULL,
        access_token_metadata TEXT DEFAULT NULL,
        access_token_type varchar(100) DEFAULT NULL,
        access_token_scopes varchar(1000) DEFAULT NULL,
        oidc_id_token_value TEXT DEFAULT NULL,
        oidc_id_token_issued_at timestamp DEFAULT NULL,
        oidc_id_token_expires_at timestamp DEFAULT NULL,
        oidc_id_token_metadata TEXT DEFAULT NULL,
        refresh_token_value TEXT DEFAULT NULL,
        refresh_token_issued_at timestamp DEFAULT NULL,
        refresh_token_expires_at timestamp DEFAULT NULL,
        refresh_token_metadata TEXT DEFAULT NULL,
        user_code_value TEXT DEFAULT NULL,
        user_code_issued_at timestamp DEFAULT NULL,
        user_code_expires_at timestamp DEFAULT NULL,
        user_code_metadata TEXT DEFAULT NULL,
        device_code_value TEXT DEFAULT NULL,
        device_code_issued_at timestamp DEFAULT NULL,
        device_code_expires_at timestamp DEFAULT NULL,
        device_code_metadata TEXT DEFAULT NULL,
        PRIMARY KEY (id)
    );


    -- Spring Session: セッション情報
    CREATE TABLE t_spring_session (
        PRIMARY_ID CHAR(36) NOT NULL,
        SESSION_ID CHAR(36) NOT NULL,
        CREATION_TIME BIGINT NOT NULL,
        LAST_ACCESS_TIME BIGINT NOT NULL,
        MAX_INACTIVE_INTERVAL_SECONDS INT NOT NULL,
        EXPIRY_TIME BIGINT NOT NULL,
        PRINCIPAL_NAME VARCHAR(100),
        CONSTRAINT T_SPRING_SESSION_PK PRIMARY KEY (PRIMARY_ID)
    );

    CREATE UNIQUE INDEX T_SPRING_SESSION_IX1 ON t_spring_session (SESSION_ID);
    CREATE INDEX T_SPRING_SESSION_IX2 ON t_spring_session (EXPIRY_TIME);
    CREATE INDEX T_SPRING_SESSION_IX3 ON t_spring_session (PRINCIPAL_NAME);

    -- Spring Session:セッション属性
    CREATE TABLE t_spring_session_attributes (
        SESSION_PRIMARY_ID CHAR(36) NOT NULL,
        ATTRIBUTE_NAME VARCHAR(200) NOT NULL,
        ATTRIBUTE_BYTES BYTEA NOT NULL,
        CONSTRAINT T_SPRING_SESSION_ATTRIBUTES_PK PRIMARY KEY (SESSION_PRIMARY_ID, ATTRIBUTE_NAME),
        CONSTRAINT T_SPRING_SESSION_ATTRIBUTES_FK FOREIGN KEY (SESSION_PRIMARY_ID) REFERENCES t_spring_session(PRIMARY_ID) ON DELETE CASCADE
    );
    ```

3.  ターミナルで以下のコマンドを実行し、PostgreSQLコンテナを起動します。

    ```bash
    docker-compose up -d
    ```

## ステップ3: アプリケーションの設定

`src/main/resources/application.yml` を以下のように編集します。

```yaml
server:
  port: 9000
  # 本番環境では必ずSSL/TLSを有効化する
  # ssl:
  #   key-store: classpath:keystore.p12
  #   key-store-password: password
  #   key-alias: authz-server

spring:
  application:
    name: internal-authz-server
  datasource:
    url: jdbc:postgresql://localhost:5432/authz_db
    username: authz_user
    password: securepassword
    driver-class-name: org.postgresql.Driver
  # データベーステーブルを自動で初期化する
  # 初回起動時のみ true にし、以降は false または validate に変更する
  sql:
    init:
      mode: always
  jpa:
    hibernate:
      ddl-auto: none # Spring JDBC を使うため none に設定
  security:
    user:
      # Spring Boot のデフォルトユーザーは使用しない
      name: ""
      password: ""
  session:
    store-type: jdbc
    jdbc:
      table-name: T_SPRING_SESSION # テーブル名を大文字に
      initialize-schema: never # schema.sqlで作成するため

# 認可サーバー設定
# issuer-uriは、リバースプロキシやロードバランサーの外部公開URLに合わせる必要がある
# 例: https://auth.example.com
# 開発中は localhost でも可
issuer-uri: http://localhost:9000

# ログ設定
logging:
  level:
    org.springframework.security: DEBUG
    com.example.internalauthzserver: DEBUG
  # セキュリティイベント用のログファイルを分離
  file:
    name: logs/app.log
  logback:
    rollingpolicy:
      file-name-pattern: logs/app-%d{yyyy-MM-dd}.%i.log
      max-file-size: 10MB
      max-history: 7
      total-size-cap: 100MB

# Actuator エンドポイント設定
management:
  endpoints:
    web:
      exposure:
        include: "health,info,prometheus,metrics"
  endpoint:
    health:
      show-details: when_authorized
```

## ステップ4: セキュリティ設定の実装

> **【注意】**
> 本手順書は Spring Boot 3.2.x を前提としていますが、元になったコードは古いライブラリバージョンを元にしていたため、いくつかの修正が必要でした。
> 特に、`SecurityConfig.java`は、Spring SecurityおよびSpring Authorization Serverの最新のAPIに合わせて更新されています。

設計書に基づき、複数の `SecurityFilterChain` を定義します。

1.  `com.example.internalauthzserver` パッケージ配下に、`InternalAuthzServerApplication.java` を作成します。これはアプリケーションのエントリーポイントとなるクラスです。

    ```java
    package com.example.internalauthzserver;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class InternalAuthzServerApplication {

        public static void main(String[] args) {
            SpringApplication.run(InternalAuthzServerApplication.class, args);
        }

    }
    ```

2.  `com.example.internalauthzserver.config` パッケージを作成します。
3.  `SecurityConfig.java` を作成し、以下のコードを記述します。

    ```java
    package com.example.internalauthzserver.config;

    import com.nimbusds.jose.jwk.JWKSet;
    import com.nimbusds.jose.jwk.RSAKey;
    import com.nimbusds.jose.jwk.source.ImmutableJWKSet;
    import com.nimbusds.jose.jwk.source.JWKSource;
    import com.nimbusds.jose.proc.SecurityContext;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.core.annotation.Order;
    import org.springframework.http.HttpMethod;
    import org.springframework.jdbc.core.JdbcTemplate;
    import org.springframework.security.config.Customizer;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.security.oauth2.jwt.JwtDecoder;
    import org.springframework.security.oauth2.server.authorization.JdbcOAuth2AuthorizationConsentService;
    import org.springframework.security.oauth2.server.authorization.JdbcOAuth2AuthorizationService;
    import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationConsentService;
    import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationService;
    import org.springframework.security.oauth2.server.authorization.client.JdbcRegisteredClientRepository;
    import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository;
    import org.springframework.security.oauth2.server.authorization.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration;
    import org.springframework.security.oauth2.server.authorization.config.annotation.web.configurers.OAuth2AuthorizationServerConfigurer;
    import org.springframework.security.oauth2.server.authorization.settings.AuthorizationServerSettings;
    import org.springframework.security.provisioning.JdbcUserDetailsManager;
    import org.springframework.security.provisioning.UserDetailsManager;
    import org.springframework.security.web.SecurityFilterChain;
    import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
    import org.springframework.web.cors.CorsConfiguration;
    import org.springframework.web.cors.CorsConfigurationSource;
    import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

    import javax.sql.DataSource;
    import java.security.KeyPair;
    import java.security.KeyPairGenerator;
    import java.security.interfaces.RSAPrivateKey;
    import java.security.interfaces.RSAPublicKey;
    import java.util.UUID;

    @Configuration
    @EnableWebSecurity
    public class SecurityConfig {

        // (1) 認可サーバーの標準エンドポイント用 SecurityFilterChain
        @Bean
        @Order(1)
        public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
            OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);
            http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)
                    .oidc(Customizer.withDefaults()); // OpenID Connect 1.0 を有効化

            http
                .exceptionHandling(exceptions ->
                    exceptions.authenticationEntryPoint(
                        (request, response, authException) -> response.sendRedirect("/login"))
                )
                .oauth2ResourceServer(resourceServer -> resourceServer.jwt(Customizer.withDefaults()));
            return http.build();
        }

        // (2) ユーザー認証用 (ログインページなど) の SecurityFilterChain
        @Bean
        @Order(2)
        public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
            http
                .authorizeHttpRequests(authorize -> authorize
                    // 公開エンドポイントは認証不要
                    .requestMatchers("/public/**", "/api/login", "/error").permitAll()
                    // それ以外はすべて認証が必要
                    .anyRequest().authenticated()
                )
                // 標準のログインフォームを有効化
                .formLogin(Customizer.withDefaults());
            return http.build();
        }

        // (3) Admin API とリソースサーバー機能用の SecurityFilterChain
        @Bean
        @Order(3)
        public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) throws Exception {
            http
                .securityMatcher("/api/**", "/messages")
                .authorizeHttpRequests(authorize -> authorize
                    .requestMatchers(HttpMethod.POST, "/api/login").permitAll()
                    .requestMatchers("/api/users/**", "/api/clients/**").hasRole("ADMIN")
                    .requestMatchers("/messages").hasAuthority("SCOPE_message.read")
                    .anyRequest().authenticated()
                )
                .oauth2ResourceServer(resourceServer -> resourceServer.jwt(Customizer.withDefaults()))
                // CSRFはステートレスなAPIでは不要な場合があるが、ここでは有効にしておく
                .csrf(csrf -> csrf.ignoringRequestMatchers(new AntPathRequestMatcher("/api/**")));
            return http.build();
        }

        // (4) CORS設定
        @Bean
        public CorsConfigurationSource corsConfigurationSource() {
            UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
            CorsConfiguration config = new CorsConfiguration();
            // ここに許可するオリジンを記述
            config.addAllowedOrigin("http://localhost:3000"); // 例: SPAのローカル開発サーバー
            config.addAllowedHeader("*");
            config.addAllowedMethod("*");
            config.setAllowCredentials(true);
            source.registerCorsConfiguration("/**", config);
            return source;
        }

        // --- データ永続化関連のBean定義 ---

        @Bean
        public RegisteredClientRepository registeredClientRepository(JdbcTemplate jdbcTemplate) {
            return new JdbcRegisteredClientRepository(jdbcTemplate);
        }

        @Bean
        public OAuth2AuthorizationService authorizationService(JdbcTemplate jdbcTemplate, RegisteredClientRepository registeredClientRepository) {
            return new JdbcOAuth2AuthorizationService(jdbcTemplate, registeredClientRepository);
        }

        @Bean
        public OAuth2AuthorizationConsentService authorizationConsentService(JdbcTemplate jdbcTemplate, RegisteredClientRepository registeredClientRepository) {
            return new JdbcOAuth2AuthorizationConsentService(jdbcTemplate, registeredClientRepository);
        }

        @Bean
        public UserDetailsService userDetailsService(DataSource dataSource) {
            // Spring Security標準のテーブルスキーマを前提とする
            JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);
            // 設計書に合わせてクエリをカスタマイズ
            manager.setUsersByUsernameQuery("select username, password, enabled from t_users where username = ?");
            manager.setAuthoritiesByUsernameQuery("select username, authority from t_authorities where username = ?");
            return manager;
        }

        @Bean
        public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
        }

        // --- JWT/JWK 関連のBean定義 ---

        @Bean
        public JWKSource<SecurityContext> jwkSource() {
            KeyPair keyPair = generateRsaKey();
            RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
            RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
            RSAKey rsaKey = new RSAKey.Builder(publicKey)
                    .privateKey(privateKey)
                    .keyID(UUID.randomUUID().toString())
                    .build();
            JWKSet jwkSet = new JWKSet(rsaKey);
            return new ImmutableJWKSet<>(jwkSet);
        }

        private static KeyPair generateRsaKey() {
            // !!注意!!
            // 本番環境では、このような起動時生成ではなく、KMSやHSMで管理された鍵を使用してください。
            KeyPair keyPair;
            try {
                KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
                keyPairGenerator.initialize(2048);
                keyPair = keyPairGenerator.generateKeyPair();
            } catch (Exception ex) {
                throw new IllegalStateException(ex);
            }
            return keyPair;
        }

        @Bean
        public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
            return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
        }

        // --- 認可サーバー設定 ---
        @Bean
        public AuthorizationServerSettings authorizationServerSettings() {
            return AuthorizationServerSettings.builder()
                .issuer(issuerUri())
                .build();
        }

        private String issuerUri() {
            // application.ymlからIssuer URIを取得するロジック
            // @Value("${issuer-uri}") private String issuerUri; のようにフィールドで受け取るのが一般的
            // ここでは簡易的にハードコード
            return "http://localhost:9000";
        }
    }
    ```

## ステップ5: 初期データの投入

アプリケーション起動時にテスト用の管理者ユーザーとクライアントを登録するため、`src/main/resources/data.sql` を作成します。

```sql
-- パスワードは 'password' をBCryptでハッシュ化したもの
-- 管理者ユーザー (ROLE_ADMIN, ROLE_USER)
INSERT INTO t_users (username, password, enabled)
VALUES ('admin', '$2b$12$iq2u42y/l/Y/iNfq1PTZxOf6Q1BgIoSrmBkrnRqt5vSS3c1VYLZNS', true)
ON CONFLICT (username) DO NOTHING;

INSERT INTO t_authorities (username, authority)
VALUES ('admin', 'ROLE_ADMIN'), ('admin', 'ROLE_USER')
ON CONFLICT (username, authority) DO NOTHING;


-- 一般ユーザー (ROLE_USER)
INSERT INTO t_users (username, password, enabled)
VALUES ('user', '$2b$12$iq2u42y/l/Y/iNfq1PTZxOf6Q1BgIoSrmBkrnRqt5vSS3c1VYLZNS', true)
ON CONFLICT (username) DO NOTHING;

INSERT INTO t_authorities (username, authority)
VALUES ('user', 'ROLE_USER')
ON CONFLICT (username, authority) DO NOTHING;


-- 登録クライアント: WebApp (機密クライアント)
-- client_secretは 'secret' をBCryptでハッシュ化したもの
INSERT INTO oauth2_registered_client (id, client_id, client_id_issued_at, client_secret, client_secret_expires_at, client_name, client_authentication_methods, authorization_grant_types, redirect_uris, scopes, client_settings, token_settings)
VALUES (
    'oidc-client-1',
    'webapp-client',
    NOW(),
    '$2b$12$KGigkFRmPqg49A/4CMPMduE6bd.WhpGLwcpS1CP.tEpdo86Kt.dvS',
    NULL,
    'Web App Client',
    'client_secret_basic',
    'refresh_token,authorization_code',
    'http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc',
    'openid,profile,message.read,message.write',
    '{"@class":"java.util.Collections$UnmodifiableMap","settings.client.require-proof-key":false,"settings.client.require-authorization-consent":true}',
    '{"@class":"java.util.Collections$UnmodifiableMap","settings.token.access-token-format":{"@class":"org.springframework.security.oauth2.server.authorization.settings.OAuth2TokenFormat","value":"self-contained"},"settings.token.access-token-time-to-live":["java.time.Duration",300.000000000],"settings.token.refresh-token-time-to-live":["java.time.Duration",3600.000000000],"settings.token.reuse-refresh-tokens":false}'
)
ON CONFLICT (id) DO NOTHING;


-- 登録クライアント: SPA (公開クライアント, PKCE必須)
INSERT INTO oauth2_registered_client (id, client_id, client_id_issued_at, client_secret, client_secret_expires_at, client_name, client_authentication_methods, authorization_grant_types, redirect_uris, scopes, client_settings, token_settings)
VALUES (
    'oidc-client-2',
    'spa-client',
    NOW(),
    NULL, -- 公開クライアントなのでシークレットはNULL
    NULL,
    'SPA Client',
    'none',
    'refresh_token,authorization_code',
    'http://127.0.0.1:3000/callback',
    'openid,profile,message.read',
    '{"@class":"java.util.Collections$UnmodifiableMap","settings.client.require-proof-key":true,"settings.client.require-authorization-consent":true}',
    '{"@class":"java.util.Collections$UnmodifiableMap","settings.token.access-token-format":{"@class":"org.springframework.security.oauth2.server.authorization.settings.OAuth2TokenFormat","value":"self-contained"},"settings.token.access-token-time-to-live":["java.time.Duration",300.000000000],"settings.token.refresh-token-time-to-live":["java.time.Duration",3600.000000000],"settings.token.reuse-refresh-tokens":true}'
)
ON CONFLICT (id) DO NOTHING;
```

## ステップ6: カスタムAPIの実装

設計書で定義された `/api/**` および `/messages` のエンドポイントを実装します。

1.  **DTO (Data Transfer Object) の作成**
    `com.example.internalauthzserver.dto` パッケージを作成し、以下のクラスを追加します。

    `LoginRequest.java`
    ```java
    package com.example.internalauthzserver.dto;
    public record LoginRequest(String username, String password) {}
    ```

    `LoginResponse.java`
    ```java
    package com.example.internalauthzserver.dto;
    public record LoginResponse(String accessToken) {}
    ```

    `UserResponse.java` (Admin API用)
    ```java
    package com.example.internalauthzserver.dto;
    import java.util.List;
    public record UserResponse(String username, boolean enabled, List<String> roles) {}
    ```
    (※ `UserRequest`, `ClientRequest`, `ClientResponse` も同様に作成しますが、ここでは省略します。)

2.  **Controller の作成**
    `com.example.internalauthzserver.controller` パッケージを作成し、以下のクラスを追加します。

    `ResourceController.java`
    ```java
    package com.example.internalauthzserver.controller;

    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    public class ResourceController {

        @GetMapping("/messages")
        public String[] getMessages() {
            return new String[]{"Message 1", "Message 2", "Message 3"};
        }

        @GetMapping("/public/hello")
        public String getPublicHello() {
            return "Hello from public endpoint!";
        }
    }
    ```

    `AdminController.java` (Admin APIの実装例)
    ```java
    package com.example.internalauthzserver.controller;

    import com.example.internalauthzserver.dto.UserResponse;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.provisioning.UserDetailsManager;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    import java.util.List;
    import java.util.stream.Collectors;

    @RestController
    @RequestMapping("/api")
    public class AdminController {

        private final UserDetailsManager userDetailsManager;

        public AdminController(UserDetailsManager userDetailsManager) {
            this.userDetailsManager = userDetailsManager;
        }

        @GetMapping("/users/{username}")
        public ResponseEntity<UserResponse> getUser(@PathVariable String username) {
            if (!userDetailsManager.userExists(username)) {
                return ResponseEntity.notFound().build();
            }
            UserDetails user = userDetailsManager.loadUserByUsername(username);
            List<String> roles = user.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toList());
            UserResponse response = new UserResponse(user.getUsername(), user.isEnabled(), roles);
            return ResponseEntity.ok(response);
        }

        // POST, PUT, DELETE の実装は省略
    }
    ```

    **(注意)** `AdminController` は `UserDetailsManager` をインジェクトして使用しています。`UserDetailsManager` はSpring Securityが提供するインターフェースで、`JdbcUserDetailsManager`はその実装クラスです。`SecurityConfig`でBean定義しているため、DIコンテナから注入できます。クライアント管理APIも同様に `RegisteredClientRepository` を使って実装できます。

## ステップ7: Docker化とデプロイ

1.  プロジェクトのルートディレクトリに `Dockerfile` を作成します。

    ```dockerfile
    # ビルドステージ
    FROM maven:3.8.5-openjdk-17 AS build
    WORKDIR /app
    COPY pom.xml .
    COPY src ./src
    RUN mvn clean package -DskipTests

    # 実行ステージ
    FROM openjdk:17-jdk-slim
    WORKDIR /app
    COPY --from=build /app/target/internal-authz-server-*.jar app.jar
    ENTRYPOINT ["java", "-jar", "app.jar"]
    ```

2.  `docker-compose.yml` を更新して、アプリケーションサービスを追加します。

    ```yaml
    version: '3.8'

    services:
      authz-server:
        build: .
        container_name: authz-server-app
        ports:
          - "9000:9000"
        depends_on:
          postgresql:
            condition: service_healthy
        environment:
          - SPRING_DATASOURCE_URL=jdbc:postgresql://postgresql:5432/authz_db
          - SPRING_DATASOURCE_USERNAME=authz_user
          - SPRING_DATASOURCE_PASSWORD=securepassword
          - ISSUER_URI=http://localhost:9000
        networks:
          - authz-net

      postgresql:
        image: postgres:14-alpine
        container_name: authz-postgres
        # コンテナ外部にポートを公開する必要がなければ ports は削除
        ports:
          - "5432:5432"
        volumes:
          - postgres_data:/var/lib/postgresql/data
        environment:
          - POSTGRES_DB=authz_db
          - POSTGRES_USER=authz_user
          - POSTGRES_PASSWORD=securepassword
        healthcheck:
          test: ["CMD-SHELL", "pg_isready -U authz_user -d authz_db"]
          interval: 10s
          timeout: 5s
          retries: 5
        networks:
          - authz-net

    volumes:
      postgres_data:
        driver: local

    networks:
      authz-net:
        driver: bridge
    ```

3.  **Docker Swarmでのデプロイ**

    a. Docker Swarmを初期化します（未実施の場合）。
    ```bash
    docker swarm init
    ```

    b. `docker-compose.yml` をもとにスタックをデプロイします。
    ```bash
    docker stack deploy -c docker-compose.yml authz_stack
    ```

    c. サービスのレプリカ数をスケールするには以下のコマンドを実行します。
    ```bash
    # authz-server サービスを3レプリカにスケール
    docker service scale authz_stack_authz-server=3
    ```

## ステップ8: 動作確認

### 8.1. 認可コードフローの確認

1.  ブラウザで以下のURLにアクセスします。
    *   **client_id**: `webapp-client` (data.sqlで登録)
    *   **redirect_uri**: `http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc` (data.sqlで登録)
    *   **scope**: `openid message.read`
    *   **response_type**: `code`

    ```
    http://localhost:9000/oauth2/authorize?response_type=code&client_id=webapp-client&scope=openid%20message.read&redirect_uri=http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc
    ```

2.  ログイン画面が表示されるので、`user` / `password` でログインします。
3.  認可同意画面が表示されたら、「Submit Consent」をクリックします。
4.  ブラウザが `redirect_uri` にリダイレクトされ、URLのクエリパラメータに `code` が付与されていることを確認します。

### 8.2. トークンエンドポイントの確認

1.  上記で取得した `code` を使用して、cURLでトークンを要求します。

    ```bash
    curl --location --request POST 'http://localhost:9000/oauth2/token' \
    --header 'Content-Type: application/x-www-form-urlencoded' \
    --user 'webapp-client:secret' \
    --data-urlencode 'grant_type=authorization_code' \
    --data-urlencode 'code=【ここに取得した認可コード】' \
    --data-urlencode 'redirect_uri=http://127.0.0.1:8080/login/oauth2/code/messaging-client-oidc'
    ```

2.  `access_token`, `refresh_token`, `id_token` を含むJSONレスポンスが返却されることを確認します。

### 8.3. リソースサーバー機能の確認

1.  上記で取得した `access_token` を使用して、保護されたリソースにアクセスします。

    ```bash
    curl --location --request GET 'http://localhost:9000/messages' \
    --header 'Authorization: Bearer 【ここにアクセストークン】'
    ```

2.  `["Message 1","Message 2","Message 3"]` のようなレスポンスが返却されることを確認します。

### 8.4. Admin APIの確認

1.  まず、管理者 (`admin`) のアクセストークンを取得する必要があります。（クライアントクレデンシャルグラント等を別途クライアントに許可し、それを利用するのが一般的です）
2.  ここでは簡易的に、`admin` ユーザーで認可コードフローを実行してトークンを取得したと仮定します。
3.  取得したトークンを使い、ユーザー情報を取得します。

    ```bash
    curl --location --request GET 'http://localhost:9000/api/users/user' \
    --header 'Authorization: Bearer 【adminユーザーで取得したアクセストークン】'
    ```

4.  一般ユーザー `user` の情報がJSON形式で返却されることを確認します。
